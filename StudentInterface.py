"""
StudentInterface.py
--------
Authors: Andrew Liu (al), Joey Le (jl)
Created: 1/22/2023
Last Modified: 2/04/2023

Purpose: This module is responsible for being the main user entrypoint to the program. It will call search functions in
search.py according to user input, passes the search data to the GraphGen module, and finally displays that data to the
user.

================ Revision History ================
jl    1/22/23    Initial file created
al    1/23/23    Reformatting changes to file
jl    1/28/23    Rendering with sample graph generation
al    1/30/23    Implement initial GUI prototype
al    2/01/23    Adapt GUI implementation to single-graph GraphGen output
al    2/03/23    Work on rewriting parts of codebase; addressing several bugs
al    2/04/23    Finalizing changes to functionality, error handling, handle multiple graphs and remaining search cases
al    2/04/23    Finalizing documentation, crushing some bugs and removing redundant code
==================================================

Requirements to run StudentInterface.py
--------
This program serves as an entrypoint and can be started on its own by calling StudentInterface.init_gui() anywhere.
Once this is called, the main thread will be blocked and a GUI will be opened, with all user input processed from there.
"""

from tkinter import ttk
from tkinter import *
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from typing import List

from search import *
from GraphGen import *


class StoredGraph:
    """
    Encapsulating class for graphs and graph figures. Holds data for graphs necessary for rendering and
    managing tkinter frames and matplotlib figures.
    """

    def __init__(self, data, max_width, max_height, parent_window, stored_array=None):
        """
        Fields:
            frame: The frame this graph will be displayed on, along with its close button
            max_width: The maximum allowed width for all graphs combined
            max_height: The maximum permitted height for all graphs
            stored_graph: The Figure instance to be generated by the GraphGen module
            rendered_graph: The final FigureCanvas to be rendered on the dataframe
            stored_array: The array in which this graph is stored and referenced from
            data: Input data with which the search function is called
        """
        self.button = None
        self.data = data
        self.max_width = max_width
        self.max_height = max_height
        self.stored_array = stored_array
        self.frame = None
        self.parent_window = parent_window
        self.stored_graph = None
        self.rendered_graph = None

    def setGraph(self, options: List, faculty_only: bool, x_label: str):
        """
        setGraph: Uses data from initialization and user provided options to generate and store data for a graph

        Parameters:
            options: User provided options
            faculty_only: Whether only faculty should be displayed or not
            x_label: x-axis label title on the graph
        """
        self.stored_graph = graphGen(data_dict=self.data, options_list=options, faculty_only=faculty_only,
                                     label=x_label)

    def pushGraph(self, dataframe: Frame, row: int, column: int, scale: int, max_width: int, max_height: int):
        """
        setGraph: uses data from initialization and user provided options to generate and store data for a graph

        Parameters:
            dataframe: The parent dataframe that the graph will be displayed on
            row: Row of the dataframe's grid to be displayed on
            column: Column of the dataframe's grid to be displayed on
            scale: Amount dimensions of each graph should be scaled down by
            max_width: The maximum allowed width for all graphs combined
            max_height: The maximum permitted height for all graphs
        """
        # Need a significant amount of padding at the bottom so names do not get cut off
        self.stored_graph.subplots_adjust(bottom=0.4)
        # Initialize the internal frame, and push it to the parent frame
        self.frame = Frame(master=dataframe, background="white")
        self.frame.grid(row=5+row, column=column, columnspan=1)
        # Button to close graphs
        self.button = ttk.Button(self.frame, text="Remove graph", command=lambda: self.hardExit())
        self.button.grid(row=0, column=0)
        # A button to remove the graph if removing it is desired
        # Initialize the graph figure and its dimensions
        self.rendered_graph = FigureCanvasTkAgg(self.stored_graph, master=self.frame)
        self.rendered_graph.get_tk_widget().grid(row=1, column=0)
        self.rendered_graph.get_tk_widget().config(width=max_width / scale, height=max_height)

    def hardExit(self):
        """
        Removes/cleans up this StoredGraph instance completely and re-renders the parent frame
        """
        # Removes this StoredGraph from its parent array
        if self.stored_array is not None and self in self.stored_array:
            self.stored_array.remove(self)
        # Necessary matplotlib and tkinter cleanup
        self.rendered_graph.get_tk_widget().destroy()
        self.frame.destroy()
        plt.close('all')
        for element in self.parent_window.grid_slaves(5, 0):
            element.destroy()
        # Re-render the frame
        dataframe = Frame(master=self.parent_window, width=self.max_width, height=self.max_height)
        dataframe.grid(row=5, column=0, columnspan=5)
        renderGraphs(self.stored_array, dataframe, self.max_width, self.max_height)

    def softExit(self):
        """
        Removes/cleans up this StoredGraph instance completely
        """
        # Removes this StoredGraph from its parent array
        if self.stored_array is not None and self in self.stored_array:
            self.stored_array.remove(self)
        # Necessary matplotlib and tkinter cleanup
        self.rendered_graph.get_tk_widget().destroy()
        self.frame.destroy()


def renderGraphs(stored_graphs: List[StoredGraph], dataframe: Frame, max_width: int, max_height: int):
    """
    render_graphs: Renders all graphs on the provided Frame

    Parameters:
        stored_graphs: List of graphs to be rendered
        dataframe: Frame to render graphs on
        max_width: Maximum total width to be scaled down to, in case of more than 2 graphs displayed
        max_height: Maximum height for all graphs
    """
    column = 0
    # Removes the oldest graph if there are more than 5 graphs in the list
    size = len(stored_graphs)
    if size > 5:
        size = 5
        # Remove the oldest graph from the array and from memory
        stored_graphs[0].softExit()
    # Clean up stored graphs
    plt.close('all')
    # Render all graphs side-by-side, left to right, oldest to newest
    for stored_graph in stored_graphs:
        stored_graph.pushGraph(dataframe, 0, column, size, max_width, max_height)
        column += 1


def processInputAndRender(max_width: int, max_height: int, faculty_list: List[str], window: Tk, subject: str,
                          input_number: str, search_type: str, search_by_a: bool, faculty_only: bool,
                          stored_graphs: List[StoredGraph]):
    """
    process_input_and_render: Creates a graph based on user input, re-renders graphs on the window

    Parameters:
        max_width: Maximum width allotted to combined graph elements; defaults to 80% of screen width
        max_height: Maximum height allotted to combined graph elements; defaults to 60% of screen height
        faculty_list: List of faculty to be passed to search and graph generation functions
        window: tkinter window element that graphs will be rendered on
        subject: user inputted subject to be passed to the search function
        input_number: user inputted class/level number to be passed to the search function
        search_type: whether the search should be by number, by level (with instructors displayed), or by level (with
                     class numbers displayed)
        search_by_a: Whether the graph generated should display A's percent or not
        faculty_only: Whether the graph generated should only display faculty or not
        stored_graphs: Reference to list of graphs to be rendered or modified
    """
    # Error message, x-axis label, search results, class level
    error, label, results, level = "", "", "", None
    # Clear existing error message, if applicable
    for element in window.grid_slaves(4, 0):
        element.destroy()
    # Only process if the input number is actually a number
    if input_number.isdigit():
        # Class level is automatically determined by the input
        level = int(int(input_number) / 100) * 100
        # Case for if search is by class number, instructor display by default
        if int(input_number) < 100:
            results = ""
            label = ""
            error = "Could not find " + subject + " classes of level " + input_number
        elif search_type == "Class number":
            results = instructorSearch(subject.upper(), level, int(input_number), faculty_list)
            label = "Instructors"
        # Case for if search is by class level with instructor display
        elif search_type == "Class level (by instructor)":
            if level < 100:
                results = ""
                label = ""
                error = "Could not find " + subject + " classes of level 0"
            else:
                results = instructorSearch(subject.upper(), level, -1, faculty_list)
                label = "Instructors"
        # Case for if search is by class level with class number display
        else:
            results = classSearch(subject.upper(), level, faculty_list, faculty_only)
            label = "Level"
    # Error case for if user input is blank
    elif input_number == "":
        error = "Must have an input for class number or level"
    # Error case for if user input number is not actually a number
    else:
        results = ""
        error = "Class number may only contain numbers (no spaces)"
    # Error handling for search output; only outputs integers when search failed
    if type(results) == int and level is not None:
        # Case where no such class number exists
        if results == CLASSNUM_ERROR:
            error = "Could not find class " + subject + " " + input_number
        # Case where no such class level exists
        elif results == LEVEL_ERROR:
            error = "Could not find " + subject + " classes of level " + str(level)
        # Case where no such subject exists
        elif results == SUBJECT_ERROR:
            error = "Could not find classes with subject " + subject.upper()
    # Displays the error below user input area if error variable is not blank
    if error != "":
        Label(window, text=error, width=0, anchor=W).grid(row=4, column=0, columnspan=5)
        return
    # Frame that will contain all the graphs to be rendered
    dataframe = Frame(master=window, width=max_width, height=max_height)
    dataframe.grid(row=5, column=0, columnspan=5)
    # Creates a new StoredGraph object with search results and appends it to the list of StoredGraphs
    graph = StoredGraph(results, max_width, max_height, window, stored_graphs)
    stored_graphs.append(graph)
    # Create a graph title based on user-provided parameters
    title = subject + " " + input_number if search_type == "Class number" else str(level) + " level " + subject
    options = [title, False, search_by_a, False]
    # Generate and render graphs
    graph.setGraph(options, faculty_only, label)
    renderGraphs(stored_graphs, dataframe, max_width, max_height)


def createDropdown(frame, options, row, column):
    """
    createDropdown: Generates a dropdown selection

    Parameters:
        frame: the parent frame that will contain the outputted GUI elements
        options: the options that the dropdown should contain
        row: row of the tkinter grid for this element to be placed
        column: leftmost column of the tkinter grid for this element to be placed

    Returns:
        A reference to the dropdown menu which is used to get the user input with selected_option.get()
    """
    # Selection reference
    selected_option = StringVar()
    selected_option.set(options[0])
    # Dropdown initialization
    dropdown = ttk.OptionMenu(frame, selected_option, *options)
    dropdown.config(text=selected_option.get())
    dropdown.grid(row=row, column=column, sticky=W)
    return selected_option


def createTextEntry(frame, text, row, column):
    """
    createTextEntry: Generates a text entry box, with a prompt to its left.

    Parameters:
        frame: the parent frame that will contain the outputted GUI elements
        text: the text prompt for the user input
        row: row of the tkinter grid for this element to be placed
        column: leftmost column of the tkinter grid for this element to be placed

    Returns:
        A reference to the text entry box which is used to get the user input with entry.get()
    """
    # Text entry box initialization
    entry = Entry(frame, width=100)
    entry.grid(row=row, column=column + 1, columnspan=5)
    # Text prompt initialization
    Label(frame, text=text, width=0).grid(row=row, column=column, padx=0, ipadx=0)
    return entry


def createOptionTextEntry(frame, options, row, column):
    """
    createOptionTextEntry: Generates a text entry box, with a dropdown next to it to signify input type.

    Parameters:
        frame: the parent frame that will contain the outputted GUI elements
        option: set of permissible options for the dropdown
        row: row of the tkinter grid for this element to be placed
        column: leftmost column of the tkinter grid for this element to be placed

    Returns:
        Tuple of the dropdown (which will be rendered outside this function), and a reference to the text entry box
        which is used to get the user input with entry.get()
    """
    # Text entry box initialization
    entry = Entry(frame, width=100)
    entry.grid(row=row, column=column + 1, columnspan=5)
    # Dropdown initialization
    dropdown = createDropdown(frame, options, row, column)
    return dropdown, entry


def initGui():
    """
    init_gui: Entrypoint for the program. Initializes GUI elements and does initial required functions from search.py.
    """
    # Selectable search parameters via dropdown menu
    faculty_option = ["All instructors", "All instructors", "Faculty only"]
    class_option = ["Class number", "Class number", "Class level (by class)", "Class level (by instructor)"]
    grade_option = ["A's %", "A's %", "F's %"]
    # GUI initialization, disabling user resizing
    gui = Tk()
    gui.title("EasyA: Search Class Data")
    gui.resizable(False, False)
    # A list of StoredGraphs mostly used to hold references to existing objects when rendering/re-rendering
    stored_graphs = []
    # Initializing the frame that will hold all tkinter elements
    frame = ttk.Frame(gui, padding=10)
    frame.grid()
    # Create dropdowns and text entry boxes for user input
    # Whether faculty only should be displayed or not
    faculty_only = createDropdown(frame, faculty_option, 3, 0)
    # Whether it should display A's or F's percent
    grade_options = createDropdown(frame, grade_option, 3, 1)
    # Textbox for subject input
    subject = createTextEntry(frame, "Subject: ", 0, 0)
    # Dropdown + text entry for search type
    search_type, class_num = createOptionTextEntry(frame, class_option, 1, 0)
    # Initialize button that will compile all user input/required parameters and pass to the graph generation function
    screen_width = gui.winfo_screenwidth()
    screen_height = gui.winfo_screenheight()
    faculty_list = getFacultyList("faculty.txt")
    ttk.Button(frame, text="Generate graph",
               command=lambda: processInputAndRender(max_width=int(screen_width * 0.8),
                                                     max_height=int(screen_height * 0.6),
                                                     faculty_list=faculty_list,
                                                     window=gui,
                                                     subject=subject.get(),
                                                     input_number=class_num.get(),
                                                     search_type=search_type.get(),
                                                     search_by_a=grade_options.get() == "A's %",
                                                     faculty_only=faculty_only.get() == "Faculty only",
                                                     stored_graphs=stored_graphs)) \
        .grid(row=3, column=2, sticky=W)
    # Open the GUI window
    gui.mainloop()
